Встречающиеся термины и понятия:

Software Development Life Cycle – SDLC – жизненный цикл разработки ПО

Software Testing Life Cycle – STLC – жизненный цикл тестирования ПО

SDLC methodologies – методологии SDLC, способы создания программного продукта.

Build – (в программировании) – сборка, конечный результат, подготовленный для использования информационный продукт.

Increment – инкремент продукта, новый, потенциально рабочий продукт, решающий бизнес-проблему, который получается в результате итерации.

Sprint – итерация разработки, отрезок времени для выполнения определенной части работы.

Backlog – набор, список задач для выполнения.

Product Backlog – бэклог продукта, требования, список всех желаемых возможностей продукта.

Что такое разработка ПО (SDLC)?

Software development life cycle – цикл разработки программного обеспечения,  включающий в себя мероприятия и процессы с момента принятия решения о создании программного продукта до его полного изъятия из эксплуатации.



SDLC состоит из следующих этапов:

1) возникает идея

2) на основании этой идеи формируются требования

3) на основании требований производится работа над дизайном продукта

4) идет его разработка

5) проводится его тестирование

6) установка в окружение, где продукт будет работать, и его дальнейшее обслуживание.

Тестирование не существует в изоляции, оно занимает свое место в каждом цикле разработки программного обеспечения. Дефекты могут возникнуть на любом этапе SDLC, при этом, в зависимости от этапа, цена исправления дефекта будет отличаться в разы. Дефект, обнаруженный на этапе разработки требований, исправляется намного быстрее и дешевле, например, самим автором требований без привлечения дополнительных людей, а вот если он обнаружен уже после релиза, то цена исправления максимально высока.

Поэтому тестировщик должен подключаться еще на этапе разработки и сбора требований, несмотря на то, что больше всего багов возникает на стадии разработки ПО. Уже на этапе формирования требований тестировщик ревьюит, находит некачественные требования. На этапе дизайна он тестирует шаблон на соответствие требованиям (проводит Usability testing). На этапе разработки тестирует UI (user interface), backend и т.д.  На этапе непосредственного тестирования - выполняет тестирование, а на этапе внедрения проводит приемочное тестирование.

Разработка ПО реализуется с помощью разных методологий (моделей). Модели реализации процесса разработки представляют собой целые системы принципов, а также совокупность идей, понятий, методов, способов и средств, определяющих стиль разработки продукта. Знание и понимание моделей позволяет тестовой команде лучше спланировать и максимально эффективно определить, какое тестирование, когда и в каком объеме будет проводиться, какие ресурсы под него выделить и т.д. Поэтому знание моделей SDLC очень важно для тестировщика.

Сами модели бывают очень различные, начиная от самых простых и быстрых, когда время выхода продукта на рынок играет ключевое значение, до суперсложных, когда основным фактором является качество и надежность.

Рассмотрим виды этих моделей. В ISTQB все модели разработки делятся на 2 группы:

1) последовательные (sequential) - стадии выполняются строго последовательно друг за другом и каждая следующая стадия начинается только после окончания предыдущей. К таким относится самая древняя модель - каскадная (Waterfall model), а также V-модель

2) итеративные (iterative, включают многократное повторение одних и тех же стадий разработки) и инкрементальные (incremental, содержат функциональное наполнение, которое наращивается с каждой итерацией). Самыми популярными являются:

·        Итеративная модель

·        Концепция Agile

Waterfall model

Waterfall – водопадная (каскадная) модель, где этапы последовательно следуют друг за другом:



1.Этап – анализ требований, полностью завершается, когда составлен список требований к ПО. 

2. Этап дизайна. Архитекторы проектируют ПО, строят его архитектуру из требований, создают документы, подробно описывающие для программистов способ и план реализации указанных требований.

3. Этап разработки. После того как проектирование полностью выполнено, разработчики кодируют архитектуру, выполняется интеграция отдельных компонентов, разрабатываемых различными командами программистов.

4. Этап тестирования идет после того как реализация и интеграция завершены. Производится тестирование и отладка продукта; тестировщики берут build, тестируют его, устраняются все недочеты, появившиеся на предыдущих стадиях

5. Этап выкладки ПО – программный продукт внедряется и обеспечивается его поддержка.

Плюсы:

- стабильность требований  в течение всего SDLC,

- определенность и понятность этапов модели и простота ее применения,

- возможность планировать сроки выполнения и соответствующие ресурсы

- этапы четко определены с самого начала, а результат ПО предсказуем.

Минусы:

- низкая гибкость в управлении проектом, пока не завершен один этап, переход к следующему невозможен,

- этапы изолированы, невозможно провести изменения их результатов для устранения возникающих проблем,

- пользователи не могут убедиться в качестве разрабатываемого продукта до окончания всего процесса разработки,

- невозможность предоставить заказчику результат, пока не завершен весь проект.

Сегодня она редко используется.

Что такое V-модель?

V-модель – это модель, где каждому этапу разработки ставится соответствующий уровень тестирования. Она направлена на тщательное тестирование продукта, который находится еще на стадии проектирования, что позволяет привлекать тестировщиков как можно раньше, буквально как только первые черновики требований уже готовы.

Стадия тестирования проводится одновременно с соответствующей стадией разработки. Стадии разработки идут сверху вниз (на рисунке они слева), а тестовые уровни расположены снизу вверх (справа):
 



На этапе написания бизнес-требований предлагается продумать приемочное тестирование, проверку системы с точки зрения конечного пользователя.

На этапе разработки функциональных требований к системе (системных требований) необходимо спланировать системные тесты, проверяющие систему целиком - от начала до конца.

На этапе архитектуры (дизайна) системы продумываем интеграционные тесты, проверяющие взаимодействие компонентов друг с другом.

На этапе реализации (кодирования) пишутся unit-тесты на конкретный модуль/компонент системы и проводится модульное тестирование.

Каждое требование тестируется в нужное время. Используется при разработке систем с важным бесперебойным функционирование, например, для интегрированного ПО для механизмов управления аварийными подушками безопасности в транспортных средствах.

Данная модель показывает, что тестирование - это не только процесс выполнения тестов, но это целый комплекс мероприятий, в том числе анализ требований/документации и подготовка к тестированию.

Плюсы:

- тестовые активности идут параллельно разработке, что сильно экономит время и способствует более качественой коммуникации внутри команды, например, на этапе acceptance testing тестировщик плотно взаимодействует с аналитиками, которые пишут требования для продукта

- требования четко определены и фиксированы

- проводится тщательное тестирование продукта, снижаются риски, т.к. тестировщики привлекаются на самых ранних этапах

Минусы:

- все-таки это последовательная модель, она неповоротлива к различного рода изменениям. А требования к бизнесу постоянно меняются, и если меняется какое-то требование к продукту, то приходится повторять все стадии от начала до конца

- время на активность по подготовке к какому-либо уровню тестирования строго ограничено временем соответствующей стадии разработки. Например, мы должны сделать подготовку к системному тестированию пока идет стадия написания требований для нашей системы, что не всегда удобно и эффективно. Поэтому тестировщики жестко привязаны к какому-то конретному уровню тестирования и лишены гибкости в нахождении максимально эффективного подхода к тестированию.

Итеративная модель

Iterative model  – это поэтапная модель с промежуточным контролем. Она подразумевает поэтапную разработку продукта стадиями которые многократно (итеративно) повторяются. Межэтапные корректировки позволяют учитывать реально существующее взаимовлияние результатов разработки на различных этапах, время жизни каждого из этапов растягивается на весь  период разработки.

Определяются группы функций, потом они проектируются, создаются и тестируются все вместе в серии циклов. Каждая итерация - это работающее программное обеспечение, которое наращивает в себе функциональность.

Iterative model включает в себя:

1.     Начальный этап – планирование. Определяются все основные требования к проекту, они подразделяются на более и менее важные.

2.     Проводится разработка системы по принципу приращений, так, чтобы разработчик мог использовать данные, полученные в ходе разработки ПО. Проводится анализ и проектирование продукта по итерациям и его последующая реализация. Каждая итерация представляет собой «мини-каскад», который имеет такой же процесс: анализ требований - планирование (проектирование) - разработка (реализация) - тестирование - демонстрация и внедрение.



Рисунок взят с сайта https://bytextest.ru/2017/12/21/iterative-model/

То есть, берется одна какая-то небольшая часть функционала на итерацию (неделя, 2 недели, месяц), по окончании итерации эта часть должна быть полностью закончена, ее можно поставлять клиенту, получить от него фидбэк, уточнить требования для следующих компонентов. Затем занимаются разработкой следующей части системы. Процесс повторяется до тех пор, пока не будут выполнены все требования, определенные на начальном этапе. Дефекты, найденные на одной итерации, легко поправить в следующей.

Таким образом, итеративная модель – это процесс простой реализации четко определенных и понятных требований к программе и доработки некоторых деталей тех пор, пока продукт не будет полностью реализован. Она характерна при разработке сложных и комплексных систем, для которых имеется четкое видение (как со стороны заказчика, так и со стороны разработчика) того, что собой должен представлять конечный результат, а также требуется ранний вывод продукта на рынок.

Плюсы:

- разработка происходит быстрее, не нужно сразу писать все требования на каждую функциональность, как в предыдущих моделях. Заказчик видит результаты уже после внедрения первой версии, т.к. первые части системы являются прототипом системы в целом, и можно сразу получить отзывы от клиента о проделанной работе, изменить требования к разработке

- затраты, которые получаются в связи с изменением требований пользователей, уменьшаются;

- у клиента есть возможность быстро получить и освоить продукт.

Минусы:

- не все продукты могут быть выпущены с минимальной функциональностью, для крупной сложной платформы наличие минимального набора функциональностей для того, чтобы она была выпущен - очень существенно;

- менеджеры должны постоянно измерять прогресс процесса;

- добавление новых компонентов в структуру может привести к ухудшению продукта, ведь постоянные изменения нарушают структуру системы, в связи с чем часто требуется дополнительное время и деньги;

- надо хорошо продумать регрессионное тестирование, ведь объем функуциональностей будет наращиваться с каждой итерацией, следовательно библиотека с регрессионным тестированием будет расти и надо быть аккуратным в планировании регрессионного тестирования в этом случае;

 Agile модель

Считается, что концепция Agile была разработана и создана под влиянием каскадной, итеративной и  V-моделей.  ISTQB приводит Agile методологию в качестве итерстивной и икрементальной модели. Условные правила, по которым Agile должен работать, записаны в Agile манифесте, который был создан в 2001 году:

- Люди и взаимодействие важнее процессов и инструментов

- Работающий продукт важнее исчерпывающей документации

- Сотрудничество с заказчиком важнее согласования условий контракта

- Готовность к изменениям важнее следования первоначальному плану

Agile модель подразумевает активное общение и сотрудничество между всеми участниками проекта. Основу этой гибкой методологии составляет разбиение проектов на небольшие задачи – User story (пользовательские истории). Согласно приоритетности задачи решают в рамках коротких двухнедельных циклов (итераций).

Структура модели имеет итеративный цикл:



Каждая итерация представляет собой небольшой объем работы, который необходимо выполнить в течение определенного периода времени – спринта (sprint). Длятся спринты от 1 до 2-х недель.

Есть 2 реализации Agile – Scrum и Kanban

Scrum характеризуется фиксированными сроками, предусмотрены четко организованные периоды работы с конкретными задачами на период. Данный метод подразумевает несколько шагов:

1. Составляется Product Backlog, в котором находятся требования. Из него будут браться задачи, оцениваться и выполняться.

2. Осуществляется Sprint Planning – планирование на реализацию некоторого количества задач, которые обязаны сделать в конце спринта. На Agile-доске рассталяются приоритеты по каждому требованию к продукту (большую роль играет владелец продукта, который собирает пожелания к продукту для оценки командой бэклога). Планируются спринты на реализацию выбранных задач.

3. Sprint Backlog – перемещение сюда набора задач (требований) из Product Backlog, выбранных для выполнения в текущем спринте.

4. Проведение Sprint Execution – разработка этих требований, результаты которых обсуждаются на еженедельных совещаниях

5. Осуществление Sprint Review – завершение задач, обзор рабочих частей продукта. На этом этапе уже имеется Potentially Shippable Increment – потенциальный продукт, который можно выпустить, конечный этап задачи.

6. Sprint Retrospective – анализ спринта, обсуждение проблемы и поиск решения после каждого спринта.

Полученный план изменения внедряется на следующем спринте. Клиенту доставляется часть проекта, которая была завершена во время спринта, на проверку и обсуждение. И так итерация повторяется: берется из Product Backlog следующая задача, оценивается и выполняется.

Kanban – второй подход к реализации методологии Agile. Предполагает обсуждение производительности в режиме реального времени и полную прозрачность рабочих процессов. Характеризуется отсутствием зафиксированных требований и зафиксированного проекта, задачи команда ставит сама себе и работает по принципу самоорганизации. Для отслеживания достижений и процесса в Kanban используют доски – элемент управления, который наглядно показывает уровень выполнения задач. Backlog – обязательно приоритезированный, задачи стоят в порядке приоритета. Из него берется задача в To Do, реализовывается (In Progress, Testing), потом переводится в Done.